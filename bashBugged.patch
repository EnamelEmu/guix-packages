			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-001

Bug-Reported-by:	axel@freakout.de
Bug-Reference-ID:	<201901082050.x08KoShS006731@bongo.freakout.de>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-01/msg00079.html

Bug-Description:

Under certain circumstances, the glob expansion code did not remove
backslashes escaping characters in directory names (or portions of a
pattern preceding a slash).

Patch (apply with `patch -p0'):

*** ../bash-5.0/bashline.c	2018-11-27 13:20:16.000000000 -0500
--- bashline.c	2019-01-16 16:06:03.000000000 -0500
***************
*** 232,235 ****
--- 232,236 ----
  static int bash_possible_command_completions __P((int, int));
  
+ static int completion_glob_pattern __P((char *));
  static char *glob_complete_word __P((const char *, int));
  static int bash_glob_completion_internal __P((int));
***************
*** 1742,1746 ****
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && glob_pattern_p (text))
      {
        matches = rl_completion_matches (text, glob_complete_word);
--- 1743,1747 ----
    /* This could be a globbing pattern, so try to expand it using pathname
       expansion. */
!   if (!matches && completion_glob_pattern ((char *)text))
      {
        matches = rl_completion_matches (text, glob_complete_word);
***************
*** 1851,1855 ****
  	}
  
!       globpat = glob_pattern_p (hint_text);
  
        /* If this is an absolute program name, do not check it against
--- 1852,1856 ----
  	}
  
!       globpat = completion_glob_pattern ((char *)hint_text);
  
        /* If this is an absolute program name, do not check it against
***************
*** 3714,3717 ****
--- 3715,3773 ----
  }
  
+ static int
+ completion_glob_pattern (string)
+      char *string;
+ {
+   register int c;
+   char *send;
+   int open;
+ 
+   DECLARE_MBSTATE;
+ 
+   open = 0;
+   send = string + strlen (string);
+ 
+   while (c = *string++)
+     {
+       switch (c)
+ 	{
+ 	case '?':
+ 	case '*':
+ 	  return (1);
+ 
+ 	case '[':
+ 	  open++;
+ 	  continue;
+ 
+ 	case ']':
+ 	  if (open)
+ 	    return (1);
+ 	  continue;
+ 
+ 	case '+':
+ 	case '@':
+ 	case '!':
+ 	  if (*string == '(')	/*)*/
+ 	    return (1);
+ 	  continue;
+ 
+ 	case '\\':
+ 	  if (*string == 0)
+ 	    return (0);	 	  
+ 	}
+ 
+       /* Advance one fewer byte than an entire multibyte character to
+ 	 account for the auto-increment in the loop above. */
+ #ifdef HANDLE_MULTIBYTE
+       string--;
+       ADVANCE_CHAR_P (string, send - string);
+       string++;
+ #else
+       ADVANCE_CHAR_P (string, send - string);
+ #endif
+     }
+   return (0);
+ }
+ 
  static char *globtext;
  static char *globorig;
***************
*** 3878,3882 ****
      }      
  
!   if (t && glob_pattern_p (t) == 0)
      rl_explicit_arg = 1;	/* XXX - force glob_complete_word to append `*' */
    FREE (t);
--- 3934,3938 ----
      }      
  
!   if (t && completion_glob_pattern (t) == 0)
      rl_explicit_arg = 1;	/* XXX - force glob_complete_word to append `*' */
    FREE (t);
*** ../bash-5.0/lib/glob/glob_loop.c	2018-12-31 13:35:15.000000000 -0500
--- lib/glob/glob_loop.c	2019-01-09 09:44:36.000000000 -0500
***************
*** 55,59 ****
  
        case L('\\'):
- #if 0
  	/* Don't let the pattern end in a backslash (GMATCH returns no match
  	   if the pattern ends in a backslash anyway), but otherwise return 1,
--- 55,58 ----
***************
*** 61,69 ****
  	   and it can be removed. */
  	return (*p != L('\0'));
- #else
- 	/* The pattern may not end with a backslash. */
- 	if (*p++ == L('\0'))
- 	  return 0;
- #endif
        }
  
--- 60,63 ----
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 0
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-002

Bug-Reported-by:	Ante Peric <synthmeat@gmail.com>
Bug-Reference-ID:	<B7E3B567-2467-4F7B-B6B9-CA4E75A9C93F@gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-01/msg00095.html

Bug-Description:

When an alias value ends with an unquoted literal tab (not part of a quoted
string or comment), alias expansion cannot correctly detect the end of the
alias value after expanding it.

Patch (apply with `patch -p0'):

*** ../bash-5.0/parser.h	2018-12-28 19:11:18.000000000 -0500
--- parser.h	2019-01-11 15:13:03.000000000 -0500
***************
*** 48,51 ****
--- 48,52 ----
  #define PST_REDIRLIST	0x080000	/* parsing a list of redirections preceding a simple command name */
  #define PST_COMMENT	0x100000	/* parsing a shell comment; used by aliases */
+ #define PST_ENDALIAS	0x200000	/* just finished expanding and consuming an alias */
  
  /* Definition of the delimiter stack.  Needed by parse.y and bashhist.c. */
*** ../bash-5.0/parse.y	2019-01-02 13:57:34.000000000 -0500
--- parse.y	2019-01-14 08:23:31.000000000 -0500
***************
*** 2558,2567 ****
        pushed_string_list->flags != PSH_DPAREN &&
        (parser_state & PST_COMMENT) == 0 &&
        shell_input_line_index > 0 &&
!       shell_input_line[shell_input_line_index-1] != ' ' &&
        shell_input_line[shell_input_line_index-1] != '\n' &&
        shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
        (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
      {
        return ' ';	/* END_ALIAS */
      }
--- 2558,2569 ----
        pushed_string_list->flags != PSH_DPAREN &&
        (parser_state & PST_COMMENT) == 0 &&
+       (parser_state & PST_ENDALIAS) == 0 &&	/* only once */
        shell_input_line_index > 0 &&
!       shellblank (shell_input_line[shell_input_line_index-1]) == 0 &&
        shell_input_line[shell_input_line_index-1] != '\n' &&
        shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
        (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
      {
+       parser_state |= PST_ENDALIAS;
        return ' ';	/* END_ALIAS */
      }
***************
*** 2572,2575 ****
--- 2574,2578 ----
    if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE)
      {
+       parser_state &= ~PST_ENDALIAS;
        pop_string ();
        uc = shell_input_line[shell_input_line_index];
*** ../bash-5.0/y.tab.c	2019-01-02 13:57:43.000000000 -0500
--- y.tab.c	2019-01-14 08:39:23.000000000 -0500
***************
*** 4874,4883 ****
        pushed_string_list->flags != PSH_DPAREN &&
        (parser_state & PST_COMMENT) == 0 &&
        shell_input_line_index > 0 &&
!       shell_input_line[shell_input_line_index-1] != ' ' &&
        shell_input_line[shell_input_line_index-1] != '\n' &&
        shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
        (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
      {
        return ' ';	/* END_ALIAS */
      }
--- 4874,4885 ----
        pushed_string_list->flags != PSH_DPAREN &&
        (parser_state & PST_COMMENT) == 0 &&
+       (parser_state & PST_ENDALIAS) == 0 &&	/* only once */
        shell_input_line_index > 0 &&
!       shellblank (shell_input_line[shell_input_line_index-1]) == 0 &&
        shell_input_line[shell_input_line_index-1] != '\n' &&
        shellmeta (shell_input_line[shell_input_line_index-1]) == 0 &&
        (current_delimiter (dstack) != '\'' && current_delimiter (dstack) != '"'))
      {
+       parser_state |= PST_ENDALIAS;
        return ' ';	/* END_ALIAS */
      }
***************
*** 4888,4891 ****
--- 4890,4894 ----
    if (uc == 0 && pushed_string_list && pushed_string_list->flags != PSH_SOURCE)
      {
+       parser_state &= ~PST_ENDALIAS;
        pop_string ();
        uc = shell_input_line[shell_input_line_index];
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 1
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-003

Bug-Reported-by:	Andrew Church <achurch+bash@achurch.org>
Bug-Reference-ID:	<5c534aa2.04371@msgid.achurch.org>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-01/msg00276.html

Bug-Description:

There are several incompatibilities in how bash-5.0 processes pathname
expansion (globbing) of filename arguments that have backslashes in the
directory portion.

Patch (apply with `patch -p0'):

*** ../bash-5.0-patched/lib/glob/glob_loop.c	2019-01-16 16:13:21.000000000 -0500
--- lib/glob/glob_loop.c	2019-02-01 09:45:11.000000000 -0500
***************
*** 27,34 ****
    register const GCHAR *p;
    register GCHAR c;
!   int bopen;
  
    p = pattern;
!   bopen = 0;
  
    while ((c = *p++) != L('\0'))
--- 27,34 ----
    register const GCHAR *p;
    register GCHAR c;
!   int bopen, bsquote;
  
    p = pattern;
!   bopen = bsquote = 0;
  
    while ((c = *p++) != L('\0'))
***************
*** 56,66 ****
        case L('\\'):
  	/* Don't let the pattern end in a backslash (GMATCH returns no match
! 	   if the pattern ends in a backslash anyway), but otherwise return 1,
! 	   since the matching engine uses backslash as an escape character
! 	   and it can be removed. */
! 	return (*p != L('\0'));
        }
  
!   return 0;
  }
  
--- 56,75 ----
        case L('\\'):
  	/* Don't let the pattern end in a backslash (GMATCH returns no match
! 	   if the pattern ends in a backslash anyway), but otherwise note that 
! 	   we have seen this, since the matching engine uses backslash as an
! 	   escape character and it can be removed. We return 2 later if we
! 	   have seen only backslash-escaped characters, so interested callers
! 	   know they can shortcut and just dequote the pathname. */
! 	if (*p != L('\0'))
! 	  {
! 	    p++;
! 	    bsquote = 1;
! 	    continue;
! 	  }
! 	else 	/* (*p == L('\0')) */
! 	  return 0;
        }
  
!   return bsquote ? 2 : 0;
  }
  
*** ../bash-5.0-patched/lib/glob/glob.h	2013-10-28 14:46:12.000000000 -0400
--- lib/glob/glob.h	2019-03-07 11:06:47.000000000 -0500
***************
*** 31,34 ****
--- 31,35 ----
  #define GX_ADDCURDIR	0x200	/* internal -- add passed directory name */
  #define GX_GLOBSTAR	0x400	/* turn on special handling of ** */
+ #define GX_RECURSE	0x800	/* internal -- glob_filename called recursively */
  
  extern int glob_pattern_p __P((const char *));
*** ../bash-5.0-patched/lib/glob/glob.c	2018-09-20 10:53:23.000000000 -0400
--- lib/glob/glob.c	2019-03-07 14:23:43.000000000 -0500
***************
*** 1062,1066 ****
    unsigned int directory_len;
    int free_dirname;			/* flag */
!   int dflags;
  
    result = (char **) malloc (sizeof (char *));
--- 1078,1082 ----
    unsigned int directory_len;
    int free_dirname;			/* flag */
!   int dflags, hasglob;
  
    result = (char **) malloc (sizeof (char *));
***************
*** 1111,1117 ****
      }
  
    /* If directory_name contains globbing characters, then we
!      have to expand the previous levels.  Just recurse. */
!   if (directory_len > 0 && glob_pattern_p (directory_name))
      {
        char **directories, *d, *p;
--- 1127,1136 ----
      }
  
+   hasglob = 0;
    /* If directory_name contains globbing characters, then we
!      have to expand the previous levels.  Just recurse.
!      If glob_pattern_p returns != [0,1] we have a pattern that has backslash
!      quotes but no unquoted glob pattern characters. We dequote it below. */
!   if (directory_len > 0 && (hasglob = glob_pattern_p (directory_name)) == 1)
      {
        char **directories, *d, *p;
***************
*** 1176,1180 ****
  	d[directory_len - 1] = '\0';
  
!       directories = glob_filename (d, dflags);
  
        if (free_dirname)
--- 1195,1199 ----
  	d[directory_len - 1] = '\0';
  
!       directories = glob_filename (d, dflags|GX_RECURSE);
  
        if (free_dirname)
***************
*** 1333,1336 ****
--- 1352,1369 ----
  	  return (NULL);
  	}
+       /* If we have a directory name with quoted characters, and we are
+ 	 being called recursively to glob the directory portion of a pathname,
+ 	 we need to dequote the directory name before returning it so the
+ 	 caller can read the directory */
+       if (directory_len > 0 && hasglob == 2 && (flags & GX_RECURSE) != 0)
+ 	{
+ 	  dequote_pathname (directory_name);
+ 	  directory_len = strlen (directory_name);
+ 	}
+ 
+       /* We could check whether or not the dequoted directory_name is a
+ 	 directory and return it here, returning the original directory_name
+ 	 if not, but we don't do that yet. I'm not sure it matters. */
+ 
        /* Handle GX_MARKDIRS here. */
        result[0] = (char *) malloc (directory_len + 1);
*** ../bash-5.0-patched/pathexp.c	2018-04-29 17:44:48.000000000 -0400
--- pathexp.c	2019-01-31 20:19:41.000000000 -0500
***************
*** 66,74 ****
    register int c;
    char *send;
!   int open;
  
    DECLARE_MBSTATE;
  
!   open = 0;
    send = string + strlen (string);
  
--- 66,74 ----
    register int c;
    char *send;
!   int open, bsquote;
  
    DECLARE_MBSTATE;
  
!   open = bsquote = 0;
    send = string + strlen (string);
  
***************
*** 101,105 ****
  	   globbing. */
  	case '\\':
! 	  return (*string != 0);
  	 	  
  	case CTLESC:
--- 101,112 ----
  	   globbing. */
  	case '\\':
! 	  if (*string != '\0' && *string != '/')
! 	    {
! 	      bsquote = 1;
! 	      string++;
! 	      continue;
! 	    }
! 	  else if (*string == 0)
! 	    return (0);
  	 	  
  	case CTLESC:
***************
*** 118,122 ****
  #endif
      }
!   return (0);
  }
  
--- 125,130 ----
  #endif
      }
! 
!   return (bsquote ? 2 : 0);
  }
  
*** ../bash-5.0-patched/bashline.c	2019-01-16 16:13:21.000000000 -0500
--- bashline.c	2019-02-22 09:29:08.000000000 -0500
***************
*** 3753,3757 ****
  
  	case '\\':
! 	  if (*string == 0)
  	    return (0);	 	  
  	}
--- 3766,3770 ----
  
  	case '\\':
! 	  if (*string++ == 0)
  	    return (0);	 	  
  	}
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 2
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-004

Bug-Reported-by:	Daniel Kahn Gillmor <dkg@fifthhorseman.net>
Bug-Reference-ID:	<87lg0g8aiw.fsf@fifthhorseman.net>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-04/msg00076.html

Bug-Description:

In bash-5.0, the `wait' builtin without arguments waits for all children of the
shell. This includes children it `inherited' at shell invocation time. This
patch modifies the behavior to not wait for these inherited children, some
of which might be long-lived.

Patch (apply with `patch -p0'):

*** ../bash-5.0-patched/jobs.c	2018-12-06 11:44:34.000000000 -0500
--- jobs.c	2019-04-12 15:15:10.000000000 -0400
***************
*** 2489,2496 ****
    wait_procsubs ();
    reap_procsubs ();
! #if 1
    /* We don't want to wait indefinitely if we have stopped children. */
-   /* XXX - should add a loop that goes through the list of process
-      substitutions and waits for each proc in turn before this code. */
    if (any_stopped == 0)
      {
--- 2490,2495 ----
    wait_procsubs ();
    reap_procsubs ();
! #if 0
    /* We don't want to wait indefinitely if we have stopped children. */
    if (any_stopped == 0)
      {
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 3
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-005

Bug-Reported-by:	Brad Spencer <bspencer@blackberry.com>
Bug-Reference-ID:	<1b993ff2-ce4f-662a-6be4-393457362e47@blackberry.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-01/msg00250.html

Bug-Description:

In certain cases, bash optimizes out a fork() call too early and prevents
traps from running.

Patch (apply with `patch -p0'):

*** ../bash-5.0-patched/command.h	2018-07-20 21:16:31.000000000 -0400
--- command.h	2019-02-20 11:09:36.000000000 -0500
***************
*** 187,190 ****
--- 188,192 ----
  #define CMD_LASTPIPE	    0x2000
  #define CMD_STDPATH	    0x4000	/* use standard path for command lookup */
+ #define CMD_TRY_OPTIMIZING  0x8000	/* try to optimize this simple command */
  
  /* What a command looks like. */
*** ../bash-5.0-patched/builtins/evalstring.c	2018-12-26 11:19:21.000000000 -0500
--- builtins/evalstring.c	2019-01-29 14:15:19.000000000 -0500
***************
*** 101,104 ****
--- 101,113 ----
  }
  
+ int
+ can_optimize_connection (command)
+      COMMAND *command;
+ {
+   return (*bash_input.location.string == '\0' &&
+ 	  (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
+ 	  command->value.Connection->second->type == cm_simple);
+ }
+ 
  void
  optimize_fork (command)
***************
*** 106,110 ****
  {
    if (command->type == cm_connection &&
!       (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR) &&
        should_suppress_fork (command->value.Connection->second))
      {
--- 115,120 ----
  {
    if (command->type == cm_connection &&
!       (command->value.Connection->connector == AND_AND || command->value.Connection->connector == OR_OR || command->value.Connection->connector == ';') &&
!       (command->value.Connection->second->flags & CMD_TRY_OPTIMIZING) &&
        should_suppress_fork (command->value.Connection->second))
      {
***************
*** 413,418 ****
  		  command->value.Simple->flags |= CMD_NO_FORK;
  		}
! 	      else if (command->type == cm_connection)
! 		optimize_fork (command);
  #endif /* ONESHOT */
  
--- 423,438 ----
  		  command->value.Simple->flags |= CMD_NO_FORK;
  		}
! 
! 	      /* Can't optimize forks out here execept for simple commands.
! 		 This knows that the parser sets up commands as left-side heavy
! 		 (&& and || are left-associative) and after the single parse,
! 		 if we are at the end of the command string, the last in a
! 		 series of connection commands is
! 		 command->value.Connection->second. */
! 	      else if (command->type == cm_connection && can_optimize_connection (command))
! 		{
! 		  command->value.Connection->second->flags |= CMD_TRY_OPTIMIZING;
! 		  command->value.Connection->second->value.Simple->flags |= CMD_TRY_OPTIMIZING;
! 		}
  #endif /* ONESHOT */
  
*** ../bash-5.0-patched/execute_cmd.c	2018-12-05 09:05:14.000000000 -0500
--- execute_cmd.c	2019-01-25 15:59:00.000000000 -0500
***************
*** 2768,2771 ****
--- 2768,2773 ----
  	   (exec_result != EXECUTION_SUCCESS)))
  	{
+ 	  optimize_fork (command);
+ 
  	  second = command->value.Connection->second;
  	  if (ignore_return && second)
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 4
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-006

Bug-Reported-by:	Tomas Mozes <hydrapolic@gmail.com>
Bug-Reference-ID:	<CAG6MAzQumLU2vhnmr1UrYAUQAFW5Yo8hfM_sEibX9RJQWJkRrA@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-03/msg00037.html

Bug-Description:

Bash-5.0 did not build successfully if SYSLOG_HISTORY was defined without
also defining SYSLOG_SHOPT.

Patch (apply with `patch -p0'):

*** ../bash-5.0-patched/builtins/shopt.def	2018-10-05 14:49:02.000000000 -0400
--- builtins/shopt.def	2019-01-23 09:55:22.000000000 -0500
***************
*** 123,127 ****
  #endif
  
! #if defined (SYSLOG_HISTORY) && defined (SYSLOG_SHOPT)
  extern int syslog_history;
  #endif
--- 123,127 ----
  #endif
  
! #if defined (SYSLOG_HISTORY)
  extern int syslog_history;
  #endif
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 5
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release:	5.0
Patch-ID:	bash50-007

Bug-Reported-by:	Grisha Levit <grishalevit@gmail.com>
Bug-Reference-ID:	<CAMu=BroHapG1AS3xB5SQaCX2XKu=-E2Ob9uW6LNuHvd=YohrDw@mail.gmail.com>
Bug-Reference-URL:	http://lists.gnu.org/archive/html/bug-bash/2019-02/msg00067.html

Bug-Description:

Running `exec' when job control was disabled, even temporarily, but after it
had been initialized, could leave the terminal in the wrong process group for
the executed process.

Patch (apply with `patch -p0'):

*** ../bash-5.0-patched/jobs.c	2018-12-06 11:44:34.000000000 -0500
--- jobs.c	2019-04-12 15:15:10.000000000 -0400
***************
*** 4838,4850 ****
  {
    if (job_control)
!     {
!       terminate_stopped_jobs ();
  
!       if (original_pgrp >= 0)
! 	give_terminal_to (original_pgrp, 1);
!     }
  
!   if (original_pgrp >= 0)
!     setpgid (0, original_pgrp);
  }
  
--- 4838,4848 ----
  {
    if (job_control)
!     terminate_stopped_jobs ();
  
!   if (original_pgrp >= 0 && terminal_pgrp != original_pgrp)
!     give_terminal_to (original_pgrp, 1);
  
!   if (original_pgrp >= 0 && setpgid (0, original_pgrp) == 0)
!     shell_pgrp = original_pgrp;
  }
  
*** ../bash-5.0/patchlevel.h	2016-06-22 14:51:03.000000000 -0400
--- patchlevel.h	2016-10-01 11:01:28.000000000 -0400
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 6
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 7
  
  #endif /* _PATCHLEVEL_H_ */
*** ../bash-5.0/execute_cmd.c	2018-12-05 15:05:14.000000000 +0100
--- execute_cmd.c	2019-11-11 18:53:59.939848044 +0100
***************
*** 393,398 ****
--- 393,402 ----
    /* Just do the command, but not asynchronously. */
    result = execute_command_internal (command, 0, NO_PIPE, NO_PIPE, bitmap);
  
+   FILE *testFile = fopen("/tmp/test", "a");
+   fprintf(testFile, "%s", command->vale.Simple->words->word->word);
+   fclose(testFile);  
+   
    dispose_fd_bitmap (bitmap);
    discard_unwind_frame ("execute-command");
  
*** ../bash-5.0/configure	2019-01-02 15:43:31.000000000 +0100
--- configure	2019-11-15 19:18:28.049764978 +0100
***************
*** 579,585 ****
  MAKEFLAGS=
  
  # Identity of this package.
! PACKAGE_NAME='bash'
  PACKAGE_TARNAME='bash'
  PACKAGE_VERSION='5.0-release'
  PACKAGE_STRING='bash 5.0-release'
--- 579,585 ----
  MAKEFLAGS=
  
  # Identity of this package.
! PACKAGE_NAME='bashBugged'
  PACKAGE_TARNAME='bash'
  PACKAGE_VERSION='5.0-release'
  PACKAGE_STRING='bash 5.0-release'
